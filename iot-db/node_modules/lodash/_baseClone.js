var Stack = require('./_Stack')

var arrayEach = require('./_arrayEach')

var assignValue = require('./_assignValue')

var baseAssign = require('./_baseAssign')

var baseAssignIn = require('./_baseAssignIn')

var cloneBuffer = require('./_cloneBuffer')

var copyArray = require('./_copyArray')

var copySymbols = require('./_copySymbols')

var copySymbolsIn = require('./_copySymbolsIn')

var getAllKeys = require('./_getAllKeys')

var getAllKeysIn = require('./_getAllKeysIn')

var getTag = require('./_getTag')

var initCloneArray = require('./_initCloneArray')

var initCloneByTag = require('./_initCloneByTag')

var initCloneObject = require('./_initCloneObject')

var isArray = require('./isArray')

var isBuffer = require('./isBuffer')

var isMap = require('./isMap')

var isObject = require('./isObject')

var isSet = require('./isSet')

var keys = require('./keys')

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1

var CLONE_FLAT_FLAG = 2

var CLONE_SYMBOLS_FLAG = 4

/** `Object#toString` result references. */
var argsTag = '[object Arguments]'

var arrayTag = '[object Array]'

var boolTag = '[object Boolean]'

var dateTag = '[object Date]'

var errorTag = '[object Error]'

var funcTag = '[object Function]'

var genTag = '[object GeneratorFunction]'

var mapTag = '[object Map]'

var numberTag = '[object Number]'

var objectTag = '[object Object]'

var regexpTag = '[object RegExp]'

var setTag = '[object Set]'

var stringTag = '[object String]'

var symbolTag = '[object Symbol]'

var weakMapTag = '[object WeakMap]'

var arrayBufferTag = '[object ArrayBuffer]'

var dataViewTag = '[object DataView]'

var float32Tag = '[object Float32Array]'

var float64Tag = '[object Float64Array]'

var int8Tag = '[object Int8Array]'

var int16Tag = '[object Int16Array]'

var int32Tag = '[object Int32Array]'

var uint8Tag = '[object Uint8Array]'

var uint8ClampedTag = '[object Uint8ClampedArray]'

var uint16Tag = '[object Uint16Array]'

var uint32Tag = '[object Uint32Array]'

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {}
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone (value, bitmask, customizer, key, object, stack) {
  var result

  var isDeep = bitmask & CLONE_DEEP_FLAG

  var isFlat = bitmask & CLONE_FLAT_FLAG

  var isFull = bitmask & CLONE_SYMBOLS_FLAG

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value)
  }
  if (result !== undefined) {
    return result
  }
  if (!isObject(value)) {
    return value
  }
  var isArr = isArray(value)
  if (isArr) {
    result = initCloneArray(value)
    if (!isDeep) {
      return copyArray(value, result)
    }
  } else {
    var tag = getTag(value)

    var isFunc = tag == funcTag || tag == genTag

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep)
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : initCloneObject(value)
      if (!isDeep) {
        return isFlat
          ? copySymbolsIn(value, baseAssignIn(result, value))
          : copySymbols(value, baseAssign(result, value))
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {}
      }
      result = initCloneByTag(value, tag, isDeep)
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack())
  var stacked = stack.get(value)
  if (stacked) {
    return stacked
  }
  stack.set(value, result)

  if (isSet(value)) {
    value.forEach(function (subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack))
    })

    return result
  }

  if (isMap(value)) {
    value.forEach(function (subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack))
    })

    return result
  }

  var keysFunc = isFull
    ? (isFlat ? getAllKeysIn : getAllKeys)
    : (isFlat ? keysIn : keys)

  var props = isArr ? undefined : keysFunc(value)
  arrayEach(props || value, function (subValue, key) {
    if (props) {
      key = subValue
      subValue = value[key]
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack))
  })
  return result
}

module.exports = baseClone
